{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"about/","title":"Welcome to MkDocs About Page","text":""},{"location":"about/#about-studytomy","title":"About Studytomy","text":"<p>At Studytomy, we believe that education has the power to transform lives. Our online platform connects students with qualified tutors and instructors from around the world, providing a personalized and convenient learning experience. Whether you're looking to excel in academics, learn a new language, or develop new skills, StudyToMy is here to support you on your educational journey.</p>"},{"location":"about/#our-mission","title":"Our Mission","text":"<p>Our mission is to empower students by providing them with access to high-quality education and learning opportunities. We strive to create a global learning community where students can connect with experienced tutors who are passionate about sharing their knowledge and expertise. At StudyToMy, we take responsibility for your child/Children's progress in education. We will provide short notes on specific sections that need more attention with topic-based questions practice as well.</p>"},{"location":"about/#comprehensive-approach","title":"Comprehensive Approach","text":"<p>StudyToMy offers a comprehensive approach that encompasses a wide array of subjects which are thoughtfully designed to equip each student with the knowledge, skills, and unwavering support they require to not only excel but truly thrive in their academic pursuits.</p>"},{"location":"about/#our-vision","title":"Our Vision","text":"<p>Our vision is to create a world where every student has the opportunity to reach their full potential through access to high-quality education. We believe that education is the key to unlocking a brighter future for individuals and communities around the globe. By providing students with the tools and resources they need to succeed, we aim to make a positive impact on the world and inspire a lifelong love of learning.</p>"},{"location":"advance-stock-manager-with-point-of-sale-system/","title":"Advance Stock Manager With Point of Sale System","text":""},{"location":"advance-stock-manager-with-point-of-sale-system/#click-here-to-buy-this-product-visit-exclusive-site-to-view-our-more-services","title":"Click here to buy this product &amp; visit exclusive site to view our more services","text":"<p>The project is written in C# (Microsoft Visual Studio 2015 or Its later version) as front end , SQLite / Microsoft SQL Server / MySQL database as back end with Crystal Reports.</p> <p></p>"},{"location":"advance-stock-manager-with-point-of-sale-system/#click-here-to-buy-this-product-visit-exclusive-site-to-view-our-more-services_1","title":"Click here to buy this product &amp; visit exclusive site to view our more services","text":""},{"location":"advance-stock-manager-with-point-of-sale-system/#or-drop-your-mail-to-quadratesolutionsgmailcom","title":"Or drop your mail to quadratesolutions@gmail.com","text":"IM NowWe are always online Send message Send message IM Now We are always online"},{"location":"aspnet-core-dotnet-8-preview-4-new-features-and-updates/","title":"ASP.NET Core .NET 8 Preview 4 New Features and Updates","text":"<p>The latest news about ASP.NET Core has been released, and it brings exciting new features and updates aimed at enhancing the development experience. The ASP.NET Core development team has been working hard to introduce these features in the latest Preview. Let's delve into the details of the new features and updates.</p> <ol> <li>Blazor:</li> <li>Streamlining SSR with Blazor Components: With the release of .NET 8, it is now possible to stream content updates to client-side using Server-Side Rendering (SSR). This allows for faster-loading server-side Blazor pages. By adding a script tag and using conditional rendering, you can optimize the page loading experience.</li> </ol> <p><code>html     @if (isServerSide)     {          &lt;script src=\"_framework/blazor.server.js\"&gt;&lt;/script&gt;     }     else     {          &lt;script src=\"_framework/blazor.webassembly.js\"&gt;&lt;/script&gt;     }</code></p> <ul> <li>Mastering Form Posts in Blazor SSR: Dealing with form posts in SSR has become easier. You can now create a model binding context using the CascadingModelBinder component, and define a form using the EditForm component. This simplifies form submission handling in Blazor SSR.</li> </ul> <p><code>html     &lt;CascadingModelBinder&gt;         &lt;EditForm Model=\"@model\" OnValidSubmit=\"@HandleValidSubmit\"&gt;             &lt;InputText @bind-Value=\"@model.Name\" /&gt;             &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;         &lt;/EditForm&gt;     &lt;/CascadingModelBinder&gt;</code></p> <ul> <li> <p>Named Element Routing in Blazor: Blazor now supports client-side routing to specific HTML elements using URL fragments. By adding an id attribute to the desired element, Blazor will automatically scroll to it when the URL fragment matches its identifier. This feature improves navigation and enhances the user experience.</p> <p><code>html  &lt;h1 id=\"myHeader\"&gt;My Header&lt;/h1&gt;  &lt;a href=\"#myHeader\"&gt;Go to my header&lt;/a&gt;</code></p> </li> <li> <p>Bye-Bye .dll Woes: Webcil Packaging for Blazor WebAssembly Apps: Webcil packaging eliminates issues related to blocked .dll file downloads or usage in Blazor WebAssembly apps. By enabling the WasmEnableWebcil property in the project file, native Windows execution content from .NET assemblies is removed, resolving these frustrations.</p> </li> <li> <p>Minimal APIs Now Support Form Binding: In minimal APIs, form binding for specific types such as IFormCollection, IFormFile, and IFormFileCollection no longer requires the FromForm attribute. This simplifies the code and improves the form binding process.</p> </li> </ul> <p>Check the below code snippet for form binding:</p> <pre><code>app.MapPost(\"/upload\", (IFormFile file) =&gt;\n{\n    // Do something with the file\n});\n</code></pre> <ol> <li>Boost Your API Development with .http Files: New API projects now come with an included .http file. This file simplifies testing your app's endpoints using the Visual Studio HTTP editor. You can define your API host address and easily test various request examples.</li> </ol> <pre><code>GET https://localhost:5001/weatherforecast\n</code></pre> <ol> <li> <p>Native AOT: Native Ahead-of-Time (AOT) compilation is now available, allowing for improved performance and reduced startup time of applications.</p> </li> <li> <p>Streamlined Logging and Exception Handling in Compile-time Minimal APIs: By enabling the Request Delegate Generator (RDG), you can automate logging and exception handling in compile-time minimal APIs. This simplifies development and enhances error handling.</p> </li> <li> <p>ASP.NET Core Metrics: The introduction of System.Diagnostics.Metrics brings improvements to ASP.NET Core metrics. New measurement types such as counters, gauges, and histograms provide more flexibility. Enhanced multi-dimensional value reporting allows for deeper performance analysis, and compatibility with cloud-native ecosystems ensures seamless integration with OpenTelemetry and other platforms.</p> </li> </ol> <p>With these new features and updates, ASP.NET Core .NET 8 Preview 4 transforms the web application development process, ensuring a smooth and pleasant experience. From Blazor enhancements to minimal APIs, Native AOT, and improved metrics, developers have the tools to create performant and scalable applications. Embrace these features and optimize your way to success!</p>","tags":["ASP.NET Core",".NET 8","Preview 4"]},{"location":"asynchronous-programming-with-async-await-task-in-csharp/","title":"Asynchronous Programming With Async Await Task in C#","text":"<p>C# and .NET Framework (4.5 &amp; Core) supports asynchronous programming using some native functions, classes, and reserved keywords.</p> <p>Before we see what is asynchronous programming, let's understand what is synchronous programming using the following console example.</p> <pre><code>static void Main(string[] args)\n{\n    LongProcess();\n\n    ShortProcess();\n}\n\nstatic void LongProcess()\n{\n    Console.WriteLine(\"LongProcess Started\");\n\n    //some code that takes long execution time \n    System.Threading.Thread.Sleep(4000); // hold execution for 4 seconds\n\n    Console.WriteLine(\"LongProcess Completed\");\n}\n\nstatic void ShortProcess() {\n    Console.WriteLine(\"ShortProcess Started\");\n\n    //do something here\n\n    Console.WriteLine(\"ShortProcess Completed\");    \n}\n</code></pre> <p>Output:</p> <pre><code>LongProcess Started\nLongProcess Completed\nShortProcess Started\nShortProcess Completed\n</code></pre> <p>In the above example, the <code>LongProcess()</code> method takes 4 seconds to complete. The <code>ShortProcess()</code> method takes a very short time to complete. But the <code>ShortProcess()</code> method has to wait for the <code>LongProcess()</code> method to complete. This is called synchronous programming.</p> <p>In synchronous programming, the program execution waits for the current task to complete before moving on to another task. This is the default behavior of the program.</p> <p>The above program executes synchronously. It means execution starts from the Main() method wherein it first executes the LongProcess() method and then ShortProcess() method. During the execution, an application gets blocked and becomes unresponsive (You can see this in Windows-based applications mainly). This is called synchronous programming where execution does not go to next line until the current line executed completely.</p>","tags":["csharp","async","await","task"]},{"location":"asynchronous-programming-with-async-await-task-in-csharp/#what-is-asynchronous-programming","title":"What is Asynchronous Programming?","text":"<p>In asynchronous programming, the code gets executed in a thread without having to wait for an I/O-bound or long-running task to finish. For example, in the asynchronous programming model, the LongProcess() method will be executed in a separate thread from the thread pool, and the main application thread will continue to execute the next statement.</p> <p>Microsoft recommends Task-based Asynchronous Pattern to implement asynchronous programming in the .NET Framework or .NET Core applications using <code>async</code> , await keywords and <code>Task</code> or <code>Task&lt;TResult&gt;</code> class.</p> <p>Now let's rewrite the above example in asynchronous pattern using <code>async</code> keyword.</p> <pre><code>static async Task Main(string[] args)\n{\n    LongProcess();\n\n    ShortProcess();\n}\n\nstatic async void LongProcess()\n{\n    Console.WriteLine(\"LongProcess Started\");\n\n    await Task.Delay(4000); // hold execution for 4 seconds\n\n    Console.WriteLine(\"LongProcess Completed\");\n\n}\n\nstatic void ShortProcess() {\n    Console.WriteLine(\"ShortProcess Started\");\n\n    //do something here\n\n    Console.WriteLine(\"ShortProcess Completed\");    \n}\n</code></pre> <p>Output:</p> <pre><code>LongProcess Started\nShortProcess Started\nShortProcess Completed\nLongProcess Completed\n</code></pre> <p>In the above example, the Main() method is marked by the async keyword, and the return type is Task. The async keyword marks the method as asynchronous. Note that all the methods in the method chain must be async in order to implement asynchronous programming. So, the Main() method must be async to make child methods asynchronous.</p> <p>The LongProcess() method is also marked with the async keyword which makes it asynchronous. The await Task.Delay(4000); holds the thread execute for 4 seconds.</p> <p>Now, the program starts executing from the async Main() method in the main application thread. The async LongProcess() method gets executed in a separate thread and the main application thread continues execution of the next statement which calls ShortProcess() method and does not wait for the LongProcess() to complete.</p>","tags":["csharp","async","await","task"]},{"location":"asynchronous-programming-with-async-await-task-in-csharp/#async-await-and-task","title":"async, await, and Task","text":"<p>Use async along with await and Task if the async method returns a value back to the calling code. We used only the async keyword in the above program to demonstrate the simple asynchronous void method.</p> <p>The await keyword waits for the async method until it returns a value. So the main application thread stops there until it receives a return value.</p> <p>The Task class represents an asynchronous operation and Task generic class represents an operation that can return a value. In the above example, we used await Task.Delay(4000) that started async operation that sleeps for 4 seconds and await holds a thread until 4 seconds. <p>The following demonstrates the async method that returns a value.</p> <pre><code>static async Task Main(string[] args)\n{\n    Task&lt;int&gt; result = LongProcess();\n\n    ShortProcess();\n\n    var val = await result; // wait untile get the return value\n\n    Console.WriteLine(\"Result: {0}\", val);\n\n    Console.ReadKey();\n}\n\nstatic async Task&lt;int&gt; LongProcess()\n{\n    Console.WriteLine(\"LongProcess Started\");\n\n    await Task.Delay(4000); // hold execution for 4 seconds\n\n    Console.WriteLine(\"LongProcess Completed\");\n\n    return 10;\n}\n\nstatic void ShortProcess()\n{\n    Console.WriteLine(\"ShortProcess Started\");\n\n    //do something here\n\n    Console.WriteLine(\"ShortProcess Completed\");\n}\n</code></pre> <p>Output:</p> <pre><code>LongProcess Started\nShortProcess Started\nShortProcess Completed\nLongProcess Completed\nResult: 10\n</code></pre> <p>In the above example, in the static async Task LongProcess() method, Task is used to indicate the return value type int. int val = await result; will stop the main thread there until it gets the return value populated in the result. Once get the value in the result variable, it then automatically assigns an integer to val. <p>An async method should return void, Task, or Task, where TResult is the return type of the async method. Returning void is normally used for event handlers. The async keyword allows us to use the await keyword within the method so that we can wait for the asynchronous method to complete for other methods which are dependent on the return value. <p>If you have multiple async methods that return the values then you can use await for all methods just before you want to use the return value in further steps.</p> <pre><code>static async Task Main(string[] args)\n{\n    Task&lt;int&gt; result1 = LongProcess1();\n    Task&lt;int&gt; result2 = LongProcess2();\n\n    //do something here\n    Console.WriteLine(\"After two long processes.\");\n\n    int val = await result1; // wait untile get the return value\n    DisplayResult(val);\n\n    val = await result2; // wait untile get the return value\n    DisplayResult(val);\n\n    Console.ReadKey();\n}\n\nstatic async Task&lt;int&gt; LongProcess1()\n{\n    Console.WriteLine(\"LongProcess 1 Started\");\n\n    await Task.Delay(4000); // hold execution for 4 seconds\n\n    Console.WriteLine(\"LongProcess 1 Completed\");\n\n    return 10;\n}\n\nstatic async Task&lt;int&gt; LongProcess2()\n{\n    Console.WriteLine(\"LongProcess 2 Started\");\n\n    await Task.Delay(4000); // hold execution for 4 seconds\n\n    Console.WriteLine(\"LongProcess 2 Completed\");\n\n    return 20;\n}\n\nstatic void DisplayResult(int val)\n{\n    Console.WriteLine(val);\n}\n</code></pre> <p>Output:</p> <pre><code>LongProcess 1 Started\nLongProcess 2 Started\nAfter two long processes.\nLongProcess 2 Completed\nLongProcess 1 Completed\n10\n20\n</code></pre> <p>In the above program, we do await result1 and await result2 just before we need to pass the return value to another method.</p> <p>Thus, you can use async, await, and Task to implement asynchronous programming in .NET Framework or .NET Core using C#.</p>","tags":["csharp","async","await","task"]},{"location":"asynchronous-programming-with-async-await-task-in-csharp/#conclusion","title":"Conclusion","text":"<p>In this article, we learned about asynchronous programming in C# using async, await, and Task. We also learned how to implement asynchronous programming in .NET Framework or .NET Core using C#.</p>","tags":["csharp","async","await","task"]},{"location":"asynchronous-programming-with-async-await-task-in-csharp/#references","title":"References","text":"<ul> <li>Asynchronous programming with async and await</li> <li>Task-based Asynchronous Pattern</li> <li>Asynchronous programming</li> <li>Asynchronous programming with async, await, Task in C#</li> </ul>","tags":["csharp","async","await","task"]},{"location":"blazor-web-api-with-jwt-auth/","title":"Microsoft Blazor Web API with JWT Authentication","text":"<p>I would like to share a guide on how to implement a JWT Authentication system into a Dotnet Core 2 Web API project that uses Microsofts new Blazor, but this same guide can be used for regular Asp.Net core 2 Web API\u2019s.</p> <p>If you have not heard of Blazor I encourage you to take a look at Blazor . In a nutshell it allows you to write client side and server side code using just C#, take a minute to let that sink in\u2026 This means no JavaScript needed to write UI, well\u2026 there are ways to still use JavaScript using the Javascript interop if there are no other library\u2019s available in C#.</p> <p>I hope you find this guide useful and I will post the source code onto GitHub.</p>","tags":["blazor","jwt","dotnetcore"]},{"location":"blazor-web-api-with-jwt-auth/#assumptions","title":"Assumptions:","text":"<ul> <li>You have Visual Studio (any edition) v15.7 or later. If you are using anything else then at least have knowledge of the dotnet command line.</li> <li>you know how to use the Nuget package manager</li> <li>You know C# and how to build a basic web project.</li> <li>You know what JWT tokens are and why you have chosen to use it :)</li> </ul>","tags":["blazor","jwt","dotnetcore"]},{"location":"blazor-web-api-with-jwt-auth/#lets-begin","title":"let\u2019s begin.","text":"<p>First off, follow this link Blazor getting started docs to go through the setup instructions for getting the Blazor templates and newest Dotnet Core 2 SDK.</p> <p>Create a project with Blazor (Asp.NET Core hosted) and give it any name you wish. At the time of writing this guide you can only choose \u201cNo Authentication\u201d on the template. I am using Blazor version 0.5</p> <p>Next step is to install a few Nuget packages into our .Server project:</p> <li>Microsoft.AspNetCore.Authentication.JwtBearer</li> <p>Your .Server .csproj file should look similar to this</p> <p>{{&lt; gist nirzaf 6a3a6901f5c2256ee0ab2a9e657cf039 &gt;}}</p> <p>Next we need to setup our Startup.cs file. First we need to Include the IConfiguration service so that we can use .appsettings.json file which we will look at in the next step. </p> <p>{{&lt; gist nirzaf 960fc1ebd20938fb065595404d091399 &gt;}}</p> <p>Now create a \u201cappsettings.json\u201d file in the root of your .Server project and open it. Add in the \u201cJwt\u201d json to setup the token. Basically we are adding in a private key \u201cKey\u201d then adding in the Issuer which is the .Server project, then we add in the Audience which will be our .Client project, the Blazor project setup means these are both the same, the expiry time is how long before the token can no longer be used. Don\u2019t worry about the \u201cConnectionStrings\u201d for now as this is for setting up a database.</p> <p></p>  appsettings.json <p> Next we go back to the Startup.cs file. Now we will tell the ConfigureService to allow JwtBearer Authentication which can later use in the controllers as [Authorize]. There is quite a number of options on the TokenValidationParameters and I won\u2019t get into all of them but they are quite self explanatory. The Configuration[\u201c\u201d] part is what talks to the appsettings.json file and looks for the key/value pairs</p> <p></p> Startup.cs in ConfigureServices method <p></p> Startup.cs <p>Now we are getting to the good stuff! Launch your app and using postman or just navigating through the browser, use \u201c http://localhost:57778/api/SampleData/WeatherForecasts\u201d and see how the data is showing in a GET request. Now stop the app and go to the SampleDataController in the .Server project, Add a [Authorize] attribute to your public class SampleDataController, you will need to add the \u201cusing Microsoft.AspNetCore.Authorization\u201d as well.</p> <p></p> SampleDataController.cs <p>Now start the app again and repeat the process for getting the data. You should now receive a 401 Unauthorized, if you did then wahey, your controller is now secure :) alternatively you can add the [Authorize] onto the methods instead of you want to just use it on a specific method.</p> <p>Next we need to create a way of building a token for the client to receive. First I will create an interface called IJwtTokenService which will have 1 method</p>","tags":["blazor","jwt","dotnetcore"]},{"location":"blazor-web-api-with-jwt-auth/#string-buildtokenstring-email","title":"string BuildToken(string email);","text":"<p>{{&lt; figure src=\"https://i.ibb.co/mcZXLcT/1-CJZi0-P9-Thno-Zh-Mp-Xs-Il-Ba-Q.png\" title=\"IJwtTokenService.cs\" &gt;}}</p> <p>Then I am creating a new class called JwtTokenService.cs in root/Service folder of .Server project (I chose to call it service folder, call it anything you want).</p> <p>{{&lt; figure src=\"https://i.ibb.co/xgxppdQ/1-BULKgm-JAO4c5u-Wpf-YTLqgg.png\" &gt;}}</p> <p> First we create a new IConfiguration dependency injection in the constructor which will allow us to use the appsettings.json. Then we create a BuildToken method to create a token which will eventually be sent back to the client. </p> <p>{{&lt; figure src=\"https://i.ibb.co/PtJWX53/1-z-e8-Qckgmq-K6-HPUoq-Lsg3-Q.png\" title=\"JwtTokenService.cs\" &gt;}}</p> <p>The next part is easy to forget as I almost always do! We need to add the service in the Startup.cs </p> <p>{{&lt; figure src=\"https://i.ibb.co/cL2t2f8/1-rf-M-Ddtr9w7-H2b-7-Cm-W8-Qg.png\"  title=\"Startup.cs\"&gt;}}</p> <p>Before we start building the controller for handling clients wanting tokens, lets build a TokenViewModel so the user can send in their Email address or whatever you will want to authenticate them (usually email and password), I will keep mine simple for the purpose of this tutorial.</p> <p>{{&lt; figure src=\"https://i.ibb.co/2t3k373/1-5-d6g-A0jv-VAU1vl-Evc8-Bd-A.png\"  title=\"TokenViewModel.cs\" &gt;}}</p> <p>Next we will build the token controller or account controller depending on how you are building your app. For this I will call it TokenController and it will be an empty API controller. We will Inject the token service and create a POST method that we can use to send the client a token</p> <p>{{&lt; figure src=\"https://i.ibb.co/n09hmsQ/1-cpt-Rp-Osb8-I8d8-LXYHl6-RPA.png\" title=\"TokenController.cs\"&gt;}}</p> <p>Now start the app and call this controller with Postman or with your program of choice. \u201c http://localhost:57778/api/Token\u201d and enter the body email and send. You will then recieve your token</p> <p>{{&lt; figure src=\"https://i.ibb.co/xmwqmYr/1-Buo-SAr2r-Bb-S6-WIAic2-DCn-A.png\" &gt;}}</p> <p>You can then copy and paste the token string into the call to http://localhost:57778/api/SampleData/WeatherForecasts and add the bearer token</p> <p>{{&lt; figure src=\"https://miro.medium.com/max/1610/1*NqRmwosJgYMiwpHxvxByyg.png\"&gt;}}</p> <p>When you send the request you will receive a Ok 200 response and you will receive the data from the controller, Hurrah! </p> <p>{{&lt; figure src=\"https://miro.medium.com/max/1595/1*jpn65Ia3Nsm0CFAAg4woJg.png\" &gt;}}</p> <p>Congratulations, you have successfully implemented JWT Authentication to your Asp.Net core 2 application.</p> <p>Now I will be showing you how to implement a simple login page with Blazor and get it to send api calls to the Server we created in Part 1 and retrieve a authentication token. We will be working in the \u201cClient\u201d solution of the project.</p> <p>Before we begin, I would like to tell you that if you are using Blazor it would be super awesome if you could use the survey link found on the index of the app when you spin it up. It will greatly help the developers inc Steve Sanderson who made this all happen, he is a true hero for C# developers. Blazor is still in an Alpha state but the more of us that report bugs and mention the amazing parts then the faster we can get this off the ground.</p>","tags":["blazor","jwt","dotnetcore"]},{"location":"blazor-web-api-with-jwt-auth/#lets-begin_1","title":"Let\u2019s begin.","text":"<p>Open up the Client solution and you will see all the usual properties, dependencies etc.. and you will see two folders. Pages and Shared, shared are considered anything that will be used across multiple pages/areas of your app and the pages themselves and individual pages. This is not a set in stone method or naming convention but one that the team at Blazor have gone with.</p> <p>{{&lt; figure src=\"https://miro.medium.com/max/327/1*f_sA6G4lFTBCPoWovl87aA.png\" title=\"Project layout\"&gt;}}</p> <p>The first thing we will be doing is creating a login.cshtml page within the Pages folder. At the time of recording this tutorial, Blazor has no view template to use, so I will be adding a razor view.</p> <p>{{&lt; figure src=\"https://miro.medium.com/max/355/1*kY3wRtIWq49Ec9UYB9FqBg.png\" title=\"Login.cshtml\" &gt;}}</p> <p>Ignore all the other files in the pages folder for now, or delete them for a cleaner looking directory, though I like to keep them around while doing setup so I can see how the Blazor team do it their way.</p> <p>So at the top of the page we add a \u201c@page \u201c/login\u201d\u201d this is what we use to give the URL. so ours will be \u201chttp://localhost:57778/login\u201d. Nice and easy! </p> <p>{{&lt; figure src=\"https://miro.medium.com/max/266/1*hi15K_EkG5HPOFSF6df2Kw.png\" title=\"Login.cshtml\" &gt;}}</p> <p>Next let\u2019s create the form. Bootstrap comes with this template so we shall use that for ease, feel free to create your own jazzy forms if you like :) As we did in part one, just an email address and password is required for our login tutorial. </p> <p>To create linked properties to the form we will create two properties, one for email and the other for password, then we will add a \u201cbind\u201d event to the input html tags which will link the two together in the form of two way binding.</p> <p>{{&lt; figure src=\"https://miro.medium.com/max/992/1*937nQ7RMkmA2DC7JwpQgXw.png\" &gt;}}</p> <p>Now let\u2019s create an event on the submit button to make sure we have hooked it up correctly. I will show you how the C# Console.Writeline() and now write to browser consoles like javascripts console.log(); When you click on Submit it will fire the method it is attached to using the \u201conchange\u201d event and write the username and password to the console. launch the web app when ready and fill the form and hit submit!</p> <p>{{&lt; figure src=\"https://miro.medium.com/max/1015/1*lEAmgCbQTDQkBkypUUQfxA.png\" title=\"Login.cshtml\"&gt;}}</p> <p>{{&lt; figure src=\"https://miro.medium.com/max/1033/1*ysAjQDlq9WCLbIGB49LqKQ.png\" title=\"Web browser /login\"&gt;}}</p> <p>As you can see we successfully show the username and password which means we have hooked it up correctly, the \u201cWASM\u201d is the Web Assembly which is the core of what makes Blazor run in the web browser, it is the result of the C# code getting compiled down so that a web browser is able to read the code, for more info on web assembly go to WebAssembly. The next phase is setting up our HTTP method to send the form to the Server.</p> <p>Create a new property called \u201cToken\u201d underneath email and password. At the top of the page add \u201c@inject HttpClient Http\u201d This is where we will inject the standard Http client that we all know and love into our page.</p> <p>We also need to move our \u201cTokenViewModel\u201d from the server solution to the \u201cShared\u201d solution, and this is another place Blazor is amazing for, we can share models across both the UI client side and the back end server side!! and don\u2019t forget to change the namespace. Build the application as well to make sure you have changed it in all the right places.</p> <p>{{&lt; figure src=\"https://miro.medium.com/max/383/1*GctA-mbOOnq2P6peL-MGMw.png\" title=\"Project structure\"&gt;}}</p> <p>We also need to add the Password property into the TokenViewModel, we are adding this in now but the password will not be needed at this stage or until Part 3 of this tutorial where we do database integration.</p> <p>{{&lt; figure src=\"https://miro.medium.com/max/408/1*ldosGvNLh4WbzoZ5-vpdcQ.png\" title=\"TokenViewModel\"&gt;}}</p> <p>Next we async Task the SubmitForm method as we will be using the HTTP async methods to call the controller. We will then new up a TokenViewModel and pass in the property values. Once this is done we can fire up the app and give it a go, when you hit submit, using the Console.WriteLine() in the method we should now receive our token from the controller, wala!</p> <p>{{&lt; figure src=\"https://miro.medium.com/max/1009/1*Li_7y7LZzB9hvbEbUdnxSA.png\" title=\"Login.cshtml\"&gt;}}</p> <p>I don\u2019t know about you guys but this is sooooo much easier in Blazor than using JavaScript library's.</p> <p>At this point we can save the token to local storage for use around a more built app, this is a bit our of the scope of this tutorial as the Blazor team are still working on having a simple library to do so, but feel free to try out the JavaScript interop which can get the job done.</p> <p>we will be creating a basic localDb with Entity Framework core and creating the full Authentication/Authorisation with our tokens for the full login experience. See you then! and enjoy Blazor!</p>","tags":["blazor","jwt","dotnetcore"]},{"location":"blazor-web-api-with-jwt-auth/#step-one-identitydbcontext-setup","title":"Step One : IdentityDbContext setup","text":"<p> First step, let\u2019s create an IdentityDbContext which is part of Entity Framework to allow us to connect to the database. We create a Data folder and then insert a new class called ApplicationDbContext, the name is up to you but generally this is what I use as it\u2019s quite generic. </p> <p>{{&lt; figure src=\"https://miro.medium.com/max/1617/1*lRvGSDHhHTzeNGrWLSLDbg.png\"&gt;}}</p> <p>Once we have created the ApplicationDbContext we can inherit the IdentityDbContext which means we can use the ASPNet identity users. Then we add in the DbContextOptions, this injects the options which we will include in the startup.cs shortly.  <p>{{&lt; figure src=\"https://miro.medium.com/max/872/1*y0aTzj9gOUiD4oGZ9ip15g.png\"&gt;}}</p> <p>Now we need to hook up the Sql connection string in the appsettings.json which is located at the root lever of the Server project. We will modify or add in the connection string depending on if your file contains a template already.</p> <p>{{&lt; highlight java&gt;}} \"ConnectionStrings\": { \"DefaultConnection\": \"Server=(localdb)\\MSSQLLocalDB;Database=JwtAuthenticationTutorial;Trusted_Connection=True;MultipleActiveResultSets=true\" } {{&lt; /highlight&gt;}}</p> <p>Next we setup the Startup.cs file to utilise the appsettings.json and point to the connection string. Add in the EF namespace Microsoft.EntityFrameworkCore then add in the service AddDbContext as shown below.</p> <p>{{&lt; figure src=\"https://miro.medium.com/max/817/1*-f4gjaqgYONMc61w9QjFVg.png\" &gt;}}</p> <p>Now we need to add the migration so we have a migration file ready to create the database. You can do this in package manager with add-migration or use dotnet core sli with dotnet ef migrations add \"initial\" . You will need to be in the Server project for this to work. Once you have done this you will notice a migrations folder in your Server project. </p> <p>{{&lt; figure src=\"https://miro.medium.com/max/435/1*VCp0vsIvlh3e_qsIDmy0Qg.png\" &gt;}}</p> <p>Now we need to create the database. In package manager console, use update-database and in dotnet core sli use dotnet ef database update</p> <p>Boom! we have a database, this is why I love Entity framework! :) You can use SSMS or the sql server in VS to view the database if you want to take a look at it.</p>","tags":["blazor","jwt","dotnetcore"]},{"location":"blazor-web-api-with-jwt-auth/#step-two-registrationlogin-controller-methods","title":"Step Two : Registration/Login controller methods","text":"<p> We can now modify the token controller to have a registration and a login method </p> <p>First we create a private method to inject the UserManager  _userManager; and add it into the controller. <p>{{&lt; figure src=\"https://miro.medium.com/max/980/1*6kLMj5V_8QKIrHoyBGNJQg.png\"&gt;}}</p> <p>Now we create the Registration method and hook up the usermanager. As this is a simple tutorial we are not doing anything fancy, just straight up calling the user manager to create a user and because we are going to be having 2 POST methods in the controller we will be creating routes which you can see at the top of the method.</p> <p>{{&lt; figure src=\"https://miro.medium.com/max/779/1*xNBppH3VUDJNon0RQEHA8g.png\"&gt;}}</p> <p>Next we need to create a login method, this will replace the GenerateToken as the method that sends back a token and the GenerateToken method will simply give the login method a token when requested.</p> <p>{{&lt; figure src=\"https://miro.medium.com/max/798/1*ijsS7qJrNbvcC8U-syVp_Q.png\"&gt;}}</p> <p>So far so good! we now have a controller that can handle registering a user and logging in a user and sending back a generated token. You can also remove the GenerateToken method and directly call the _tokenService in the Login method, this is completely up to you, the latter would produce less code.</p> <p>In this final part we will create a registration page, modify the login page and then wala! we will have a fully working JWT authentication registration and login Blazor app.</p> <p>First, create a new razor view page like we did in Part 2 and copy and paste or re type out the same form. Change the @page name to \u201c/registration\u201d and while your at the top of the page, insert this line which will help us redirect once we login</p> <p><code>@inject Microsoft.AspNetCore.Blazor.Services.IUriHelper UriHelper</code></p> <p>remove the Token property and add in the redirect. For simplicity we are not handling any errors when logging in, I will leave that to you. In this we are handling what we assume will always be a success! </p> <p>{{&lt; figure src=\"https://miro.medium.com/max/1154/1*N9cLKA-znqUrp5vLEZNdWA.png\"&gt;}}</p> <p>Go ahead and fire up the application, direct yourself to /registration and then post the form. At this point we have been redirected to the login page where we can now make a small modification to where the API points to.</p> <p>{{&lt; figure src=\"https://miro.medium.com/max/1117/1*q6C22T4hmfpoWQAUgXyWnA.png\"&gt;}}</p> <p>And now the final bit left to do is fire up the app again and use the login form to get the token back.</p> <p>Like mentioned in Part 2, we can save the local use javascript interop and then save it to localStorage, but I will leave that up to you.</p> <p>Also 1 more note, if you are using JWT authentication, it is highly recommended that you use HTTPS. This can easily be achieved in Dotnet Core 2.1 thanks to the controller using it as standard but at the time of writing this I used 2.0 and hence the tutorial does not include HTTPS.</p> <p>That\u2019s it for this tutorial, hope you enjoyed it and most of all I hope that this will help you in creating your own JWT authentication apps. This was a very basic example of how a registration/login system works. JWT is super powerful and I encourage you to read further on how it can help you solve authentication to different areas of your application.</p> <p>And remember to support Blazor as it is in my opinion going to be a total game changer to web development :)</p>","tags":["blazor","jwt","dotnetcore"]},{"location":"contact/","title":"Welcome to Contact Page","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"contact/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"contact/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"}]}